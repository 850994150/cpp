
[TOC]

# C++


## 内核态和用户态区别

1. 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）
   此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈
2. 当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）
   此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。
3. 用户态切换到内核态
   1. 系统调用
   2. 异常、中断


## 系统调用和函数调用

1. 函数库调用是语言或应用程序的一部分，而系统调用是操作系统的一部分。
2. 用户应用程序访问并使用内核所提供的各种服务的途径即是系统调用
   在内核和用户应用程序相交界的地方,内核提供了一组系统调用接口，通过这组接口，应用程序可以访问系统硬件和各种操作系统资源。
3. 系统调用是为了方便应用使用操作系统的接口;
   而库函数是为了方便人们编写应用程序而引出的，比如你自己编写一个函数其实也可以说就是一个库函数。
4. 系统调用可以理解为内核提供给我们在用户态用的接口函数，可以认为是某种内核的库函数; 系统调用比库函数调用更耗时
5. read就是系统调用,而fread就是C标准库函数.


## 为什么系统调用比库函数调用更耗时?

1. 系统调用一般都需要保存用户程序的上下文(context), 
   在进入内核得时候需要保存用户态的寄存器，在内核态返回用户态得时候会恢复这些寄存器得内容, 这是一个开销的地方
2. 当程序中有系统调用语句，程序执行到系统调用时，首先使用类似int 80H的软中断指令，保存现场，去的系统调用号, 在内核态执行，然后恢复现场.
3. 每个进程都会有两个栈，一个内核态栈和一个用户态栈。当执行int中断执行时就会由用户态，栈转向内核栈。系统调用时需要进行栈的切换。而且内核代码对用户不信任，需要进行额外的检查。系统调用的返回过程有很多额外工作，比如检查是否需要调度等。


## 说一说 static

0. [内存分配、生命周期]
   static修饰的变量在编译阶段被编译器分配在全局区, 其生命周期随程序的结束而结束
1. [静态局部变量]
   static修饰局部变量时，使得被修饰的变量成为静态变量，存储在静态区。存储在静态区的数据生命周期与程序相同;
   但是作用域只限制于其所在的函数中。 main函数执行之前初始化，程序退出时销毁。（无论是局部静态还是全局静态）
2. [静态全局变量]
   全局变量本来就存储在静态区，因此static并不能改变其存储位置。但是，static限制了其链接属性;
   被static修饰的全局变量只能被该包含该定义的文件访问（即改变了作用域）。
3. [修饰函数]
   static修饰函数使得函数只能在包含该函数定义的文件中被调用。对于静态函数，声明和定义需要放在同一个文件夹中。
4. [类static成员变量]
   用static修饰类的数据成员使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象，所有的对象都只维持
   同一个实例。 因此，static成员必须在类外进行初始化(初始化格式：intse::var=10;)，而不能在构造函数内进行初始化
   不过也可以用const修饰static数据成员在类内初始化。 静态成员变量在构造类之前就存在了，所有类对象只有一份拷贝
5. [static成员函数]
   用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针，因而只能访问类的static成员变量
   只可以访问static成员，因为没有this指针
6. [隐藏]
   用static修饰的变量或函数仅在本文件内有效， 所以用static可以在不同文件中定义相同名称的变量或函数

## 说一说 extern

1. extern int g_Int;
   它的作用就是声明函数或全局变量的作用范围的关键字, 其声明的函数和变量可以在本模块或其他模块中使用,不能重复初始化
2. 声明函数的时候使用extern C, 可以让编译器按照C语言的方式生成函数的符号


## 说一说 const

1. const修饰变量(包括指针)
   const int a = 10;
   const int *p = 10; // 表示*p的值不允许改变，*p = 100;// error; int b = 20; p = &b; // ok
   int c = 10;
   int * const p = &c; // p存放了一个固定的地址，所以初始化的时候要给他一个初值，表示p的地址不允许改变
   					   // int d = 20; p = &d // error; c = 20; //ok
2. const修饰函数参数
   char* strcpy(char* dst, const char* src); // 防止src在strcpy函数内部被改变

3. const修饰函数返回值
   const int get(); // 防止get() 函数返回值被改变
4. const修饰函数
   int get() const; // 只可以用于类成员函数, 表示get()函数仅可访问类成员变量, 但是不可以改变类成员变量; 只能调用const
   成员函数，因为get()函数隐含了一个const this*指针
5. const和#define的区别
   #define是在预处理截断进行替换; const会在编译阶段替换, 会做安全检查, define只是简单地做替换, const会报错, 便于调试


## 比较const和#define

1. const 常量有数据类型, 而宏常量没有数据类型。编译器可以对前者进行类型安全检查。
   而define只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
2. 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。



## new/free和malloc/delete的区别

1. [性质] new是操作符，操作符可以进行重载，malloc是库函数
2. [使用] new使用的时候会自动计算大小，malloc则要指定大小
3. [成功] new成功后返回对象类型的指针，malloc返回void*指针，需要自己做类型转换
4. [失败] new抛出异常，malloc返回会NULL，所以用new之后在判断是否为NULL没什么意义
5. [扩容] new不支持扩容, malloc在使用过程中发现内存不够可以使用realloc来进行扩容

## strcpy

```
char* strcpy(char* dst, const char* src)
{
	assert(dst!=NULL);
	assert(src!=NULL);
	while((*dst++ = *src++)!= '\0');
	return dst;
}
```

## memcpy

```
char* memcpy(char* dst, const char* src, size_t n)
{
	assert((dst!=NULL) && (src!=NULL));
	while((*dst++ = *src++) != '\0' && --n);
}
```

## strcmp

```
int MyStrcmp(const char* str1, const char* str2)
{
	assert((dst!=NULL) && (src!=NULL));
    while ((*str1++ == *str2++)!='\0' && *str1 && *str2);
    int result = *(--str1) == *(--str2) ? 0 : (*(--str1) > *(--str2) ? 1 : -1);
}
```

## 什么时候要用虚析构函数

1. 虚函数是动态绑定的基础。假如析构函数不是virtual的，就不会发生动态绑定，而是静态绑定，指针的静态类型为基类指针，因此在
   delete时候只会调用基类的析构函数，而不会调用派生类的析构函数。这样，在派生类中申请的资源就不会得到释放，就会造成内存泄漏
2. 由于基类函数是虚函数（派生类相应函数就自动变虚函数，所以派生类同名函数可以不指定为虚函数）


## 对内存的理解

1. 内存管理方式[生存周期]
   静态存储连续性: 函数外定义的变量和使用satic定义的变量, 他们在整个程序运行过程中都存在
   自动存储连续性: 函数内定义的局部变量(包括函数参数), 他们在开始执行所属函数时被创建, 执行完函数后被释放
   线程存储连续性: 用thread_local定义的变量, 其声明周期和所属线程一样
   动态存储连续性: 用new/malloc动态申请的变量, 申请时被创建, 直到用delete/free将其释放

2. 内存分区[如何进行分配存放]
   栈区: 由编译器自动分配释放, 存放函数参数值和局部变量值等
   堆区: 由程序员动态申请释放, 存放用new/malloc等申请的变量
   代码区: 存放二进制代码
   全局区/静态存储区: 这块内存在程序编译的时候就已经分配好了, 存放全局变量和静态变量
   文字常量区: 存放字符串常量, 程序结后由系统释放

3. 内存动态分配
   new和malloc的区别


## 多态实现方式

1. 编译时多态
重载
   同一类中的同名函数是重载, 这些方法的名称相同, 但是参数类型或个数不同, virtual关键字可有可无
   不同类中同名函数可能是覆盖，也可能是隐藏。根据是否有virtual以及函数参数是否相同区分；
隐藏
   指派生类的函数屏蔽了与其同名的基类函数，派生对象都是调用派生类的同名函数。
   1）如果子类的函数与父类同名，但是参数不同，此时不论有无virtual关键字、基类的函数都将被隐藏;
   2）如果子类的函数与父类同名，且参数也相同，但是基类函数没有virtual关键字，此时基类的函数被隐藏
      别和覆盖混淆了,覆盖是必须有virtual关键字

2. 运行时多态
重写(覆盖)
   是指子类重新定义父类虚函数的方法, 以实现不同的功能; 函数体特征相同(函数名、参数类型个数),基类要是虚函数


## 指针

### 数据和指针的区别

1. 修改内容上的差别(比如++运算和字符常量)
2. sizeof的差别
3. 数组名的作用以及数组名前面添加取地址符的作用
   1）数组名是数组首地址，是一个常量，不可以当作指针变量用，如：若str为数组名，str++就不合法，相当于常量自增。
      再次注意：数组名是常量！常量！常量！常量就不可被赋值
      ```
      char s[10];
      char *pt, s="hello"；//将常量赋给s，实质就是将常量首地址赋值给s；
      s=pt; // 错误的，s是数组名不可被赋值，任何形式的赋值都不可以。
      ```
   2）同时，一维数组名当被直接使用时，是一个指向数组首地址的指针。
   4）数组名表示首地址，那么数组名前有取地址符是什么意思？
      例如：数组a[]，a表示数组首元素地址，&a表示数组整体地址，&a+1就是该数组末尾后一个地址

### 数组指针、指针数组、函数指针

1. 数组指针：
   `int (*p)[n];`
   其中( )优先级高，首先说明p是一个指针，指向一个整型的一维数组（或二维数组的某一行）
2. 指针数组:
   `int *p[n];`
   1) 其中[]优先级高，先与p结合成为一个数组，再由`int*`说明这是一个整型指针数组，它有n个指针类型的数组元素。
   2) `int *p=new int(12)与int *p=new int[12]`的区别 
      答：前者表示创建一个指针变量，其指向一个存储数字12的地址; 后者表示创建一个长度为12的数组。
3. 函数指针:
   `int (*pf)(int *)`
   为一个返回值为int，参数为`int*`的函数指针

### 引用和指针的区别

1. 引用要在定义的时候就初始化，而且只是个符号，不占用空间
2. 指针可以为空，但是引用不可以为空，而且应用在初始化之后就不许修改了，指针则可以随时改变指向
3. sizeof(引用) = 原变量大小; sizeof（指针）= 4或8字节

### 野指针

1. 产生
   1) 声明指针的时候, 没有初始化为NULL, 这样的话这个指针指向什么地方都是不确定的
   2) 释放动态申请的内存时, 只delete或free了, delete只是表示程序释放
      delete 释放空间，只是做个标志，表示p所在的空间可以被其他进程使用了
      没释放之前，使用权是当前进程的；而且还需把指针p赋为NULL
2. 危害
   1) 指向不可访问地址
   2) 破坏正在使用的地址空间

3. 防范
   定义指针的时候就进行初始化


## 柔性数组
1. 在结构体末尾声明0长数组，对于编译器来说，此时长度为0的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量
   这个符号本身代表了一个不可修改的地址常量 （注意：数组名永远都不会是指针！ ）;
   但对于这个数组的大小，我们可以进行动态分配
```
typedef struct FlexiableStruct
{
    int a;
    char array[0]; //或char array[]; // 定义0长数组,只是把一个符号放在结构体内, 不占用内存
}stFlexiable, *pstFlexiable;
pstFlexiable p_stFlexiable = (pstFlexiable)malloc(sizeof(stFlexiable) + strlen(szStr) + 1); // 给柔性数组申请空间
```

2. 动态申请的内存只是申请给数组拓展所用，结构体的大小在创建时已经确定了
   array明确来说不算是结构体成员，只是挂羊头卖狗肉而已
   这样的变长数组常用于网络通信中构造不定长数据包，不会浪费空间浪费网络流量

## 进程

### fork
1. 写时复制(copy-on-write):
   1) fork()进程如果没有调用exec的话, 其代码空间和父进程是一样的
   2) 只有在fork之后exec之前两个进程用的是相同的物理空间（内存区）
      子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说
      两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有
      更改相应段的行为发生时，再为子进程相应的段分配物理空间
   3) 资源的复制只有在写入的时候才进行

### 僵尸进程和孤儿进程

1. 僵尸进程
   1) 什么是僵尸进程
      父进程还在运行, 而子进程挂了, 但父进程没有使用wait来清理子进程的进程信息
      导致子进程虽然运行实体已消失, 但是仍在内核进程表中占有数据, 造成资源浪费
   2) 解决方法
      杀死其所属父进程, 使其孤儿进程
      wait
         主进程阻塞, 随便一个子进程结束就停止阻塞
      waitpid
         非阻塞, 但需要用轮询的方式监控子进程
      signal
         其实是子进程退出时会给父进程一个信号, signal里用wait或waitpid都是非阻塞的
         只要父进程还在就都会监测子进程信号, 可以把所有子进程都回收

2. 孤儿进程
   子进程还在运行, 而父进程挂了, 子进程变为孤儿进程, 将由init进程收养

3. wait 和 waitpid的区别
   从本质上讲，系统调用waitpid和wait的作用是完全相同的，但waitpid多出了两个可由用户控制的参数pid和options
   从而为我们编程提供了另一种更灵活的方式
   sub_pid = waitpid(-1, &stat, WNOHANG);
   >0    只等待进程ID等于指定进程号的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束 waitpid就会一直等下去。
   =-1   等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。 　　
   =0    等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。
   <-1   等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值


### 守护进程

### 进程间通信

> 管道(FIFO)、信号、共享内存、消息队列、信号量、套接字; IPC好像都是通过一个ID来让进程间通讯

1. 无名管道
   1. 其实就是依靠fork函数, 利用fork来和父进程公用一个管道
   2. 参数 filedis 返回两个文件描述符：filedes[0] 为读而打开
   ```
   int pipe(int filedis[2]) // 1. 创建无名管道(fork之前)
   close(file_descriptors[INPUT]); // 2. 关闭管道的读端
   write(file_descriptors[OUTPUT], "test data", strlen("test data") + 1); // 写入数据
   close(file_descriptors[OUTPUT]); // 关闭管道的写端
   read(file_descriptors[INPUT], buf, sizeof(buf)); // 读取数据
   ```

2. 有名管道
   1. 可以认为是通过文件来进行进程间通信, 写入读出的对象都是一个文件
   2. 管道都有同步和阻塞的问题, 读写有等待的情况; 而且当读写的数据大于最大长度时会阻塞等待
   ```
   mkfifo(PIPENAME, 0666);    // 1. 创建管道
   open(PIPENAME, O_WRONLY);  // 2. 打开管道
   write(fd, &i, sizeof(i));  // 3. 写数据
   close(fd);                 // 4. 关闭管道
   ```

3. 消息队列
   1. 和有名管道一样, 发送的数据都有一个最大长度限制
   2. 生命周期随内核，消息队列会一直存在，需要我们显式的调用接口或使用命令删除
   3. 消息队列可以双向通信
   4. 克服了管道只能承载无格式字节流的缺点
   ```
   #include<sys/msg.h>
   key_t key = ftok("./", 88);                  // 1. ftok 产生key
   int msgget(key_t key,int msgflg);            // 2. 建立消息队列
   int msgsnd(int msgid,void *msg_ptr,size_t msg_sz,int msgflag);
                                                // 3.1 发送消息 0 阻塞 IPC_NOWAIT 非阻塞
   int msgrcv(int msgid,void *msg_ptr,size_t msg_sz,long int msg_type,int msgflag);
                                                // 3.2.  接收消息类型为msgtype的消息
   int msgctl(int magid,int cmd,struct msgid_ds *buf);
                                                // 4. 控制消息队列(也i可以删除) 
   ```

4. 共享内存
   1. 因为系统内核没有对访问共享内存进行同步，您必须提供自己的同步措施, 比如用信号量进行同步
   ```
   #include<sys/shm.h>
   key_t key = ftok("./", 88);                                 // 1. ftok 产生key
   int shmget(key_t key,size_t size,int shmflag);              // 2. 产生信号量ID
   void *shmat(int shm_id,const void *shm_addr,int shm_flag);  // 3. 映射共享内存地址
   int shmctl(int shm_id,int cmd,struct shmid_ds *buf);        // 4. 控制共享内存(也可以删除)
   int shmdt(const void *shm_addr);                            // 5. 解除映射
   ```

5. 信号量 Pv：
   解决进程间同步与互斥问题的一种进程间通讯机制
   ```
   #include<sys/sem.h>
   key_t key = ftok("./", 88);                                 // 1. ftok 产生key
   int semget(key_t key,int num_sems,int sem_flgs);            // 2. 产生信号量ID
   int semctl(int sem_id,int sem_num,int command...);          // 3. 控制信号量(也可以删除)
   int semop(int sem_id,struct sembuf *sem_ops,size_t num_sem_ops); // 解锁或锁定共享资源
   ```

6. ![基于套接字通信](http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png)
   所有的方法都是基于套接字通信的, 所以都有个套接字的入参
   1. 服务器
      1. 创建socket套接字
      2. bind绑定地址和端口
      3. 设置套接字为listen状态,等待客户端链接
      4. accept接收到客户端连接进来, 创建新套接字与该客户端进行通信
      5. 进行读recv写send通信
      6. 关闭套接字
   2. 客户端
      1. 创建socket套接字
      2. connect与服务器进行链接(三次握手)
      3. 与服务器进行收recv发send通信
      4. 关闭套接字


## 线程


### 线程同步

1. mutex、lock_guard、unique_lock

2. condition_variable + unique_lock + notify_once + wait

3. future、promise、async、atomic

### 死锁

1. 产生原因
   陷入互相等待的状态
   A线程锁住了mutex1, 在想用mutex2锁住的变量时尝试锁mutex2, 发现mutex2被锁了, 等待mutex2释放
   B线程锁住了mutex2, 在想用mutex1锁住的变量时尝试锁mutex1, 发现mutex1被锁了, 等待mutex1释放
   原因是A、B线程锁互斥量的顺序不一致, 解锁顺序倒是不影响
2. 解决：
   1) std:lock() 函数模板
      std:lock(mutex1, mutex 2)
      解锁还是要手工unlock()，解锁顺序不影响
      可以一次锁住>=2个互斥量，不存在因锁的顺序问题而导致死锁的存在，会等所有都锁住才继续往下走
      原理:
      如果有一个互斥量没锁成功，则会释放掉已锁成功的互斥量，过段时间再去尝试，直到把所有互斥量都锁住为止
      缺点:
      lock()解决死锁的痛点在于存在忘记unlock的危险，而lock_guard刚好可以自动unlock，可否两者优点都有呢？
   2) lock() 和 lock_guard
      使用lock_guard的adopt_lock参数可以做到，让lock_guard构造的时候不lock, 但是必需在lock_guard之前加锁
      std:lock（mutex1,mutex2)
      lock_guard<mutex>lock_guard(mutex1, adopt_lock)
   3) atomic 原子操作
      类模板atomic声明的对象确保了该操作是原子性的, 不需要加锁
      std::atomic<int> g_atomic_counter(0); // atomic是一个类模板
      g_atomic_counter++;


# 计算机网络和网络安全


## TCP/UDP的区别

1. 用户数据包协议
   UDP是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。
2. 传输控制协议
   TCP是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流
   把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块

3. TCP通过确认机制，丢包可以重发，保证数据的正确性;
   UDP不保证正确性，只是单纯的负责发送数据包；

4. UDP是面向报文的。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付给 IP 层
   既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小；

5. UDP的头部，只有 8 个字节，相对于TCP头部的 20 个字节信息包的额外开销很小。

## 三次握手

## 长连接、短链接

## HTTP的GET/POST的区别

1. GET：当客户端要从服务端读取数据时用GET，使用GET方法时，请求参数和对应的值 附加在URL后面
   利用问号?代表URL的结尾和请求参数的开始，传递参数长度受限制，例：/index.jsp?id=100&op=bind

2. POST:是向服务器提交数据，POST方法请求参数封装在HTTP请求数据中，可以传输大量数据，可用来传送文件。

3. Get和Post请求的区别：
   Get是向服务器索取数据的一种请求，而Post是向服务器提交数据的一种请求
   [参数传递方式]Get请求的参数会跟在url后进行传递,它对传输的数据有[大小限制] POST请求的数据会放置在请求头内提交
   [安全性]Post比Get安全

## 浏览器输入地址后发生了什么

1. DNS服务把url转ip
2. 进行三次握手, 建立TCP/IP链接
3. 浏览器发起HTTP的post请求
4. 请求由应用层不断包装进入到数据链路层, 然后经过路由转发(拆解到网络层), 最终经过防火墙\NAT到达目的主机
5. 服务器处理该HTTP请求, 返回HTML文件
6. 浏览器解析HTML文件, 展示

## 常用端口


## time_wait状态

1. TIME_WAIT 状态，超时时间占用了 2MSL(Maximum segment lifetime) 有这个状态是两方面的原因
   1. 一个数据报在发送途中或者响应过程中有可能成为残余的数据报，因此必须等待足够长的时间避免新的连接会收到先前连接的残余数据报，而造成状态错误。
   2. 确保被动关闭方已正常关闭



## 滑动窗口机制

1. 由发送方和接收方在三次握手阶段，互相将自己的最大可接收的数据量告诉对方, 也就是自己的数据接收缓冲池的大小;
   这样对方可以根据已发送的数据量来计算是否可以接着发送。
2. 在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知

## 拥塞避免机制

1. 拥塞
   对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，网络的吞吐量随之负荷的增大而下降。
2. 拥塞控制
   防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。
3. 拥塞控制方法
   慢启动 + 拥塞避免;
   快重传 + 快恢复。


# 网络编程

# 数据结构与算法

