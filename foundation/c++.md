
[TOC]

# C++

## 说一说 static

0. [内存分配、生命周期]
   static修饰的变量在编译阶段被编译器分配在全局区, 其生命周期随程序的结束而结束
1. [局部变量]
   static修饰局部变量时，使得被修饰的变量成为静态变量，存储在静态区。存储在静态区的数据生命周期与程序相同
   在main函数之前初始化，在程序退出时销毁。（无论是局部静态还是全局静态）
2. [全局变量]
   全局变量本来就存储在静态区，因此static并不能改变其存储位置。但是，static限制了其链接属性;
   被static修饰的全局变量只能被该包含该定义的文件访问（即改变了作用域）。
3. [修饰函数]
   static修饰函数使得函数只能在包含该函数定义的文件中被调用。对于静态函数，声明和定义需要放在同一个文件夹中。
4. [类static成员变量]
   用static修饰类的数据成员使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象，所有的对象都只维持
   同一个实例。 因此，static成员必须在类外进行初始化(初始化格式：intse::var=10;)，而不能在构造函数内进行初始化
   不过也可以用const修饰static数据成员在类内初始化。 静态成员变量在构造类之前就存在了，所有类对象只有一份拷贝
5. [static成员函数]
   用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针，因而只能访问类的static成员变量
   只可以访问static成员，因为没有this指针
6. [隐藏]
   用static修饰的变量或函数仅在本文件内有效， 所以用static可以在不同文件中定义相同名称的变量或函数

## 说一说 extern

1. extern int g_Int;
   它的作用就是声明函数或全局变量的作用范围的关键字, 其声明的函数和变量可以在本模块或其他模块中使用,不能重复初始化
2. 声明函数的时候使用extern C, 可以让编译器按照C语言的方式生成函数的符号


## 说一说 const

1. const修饰变量(包括指针)
   const int a = 10;
   const int *p = 10; // 表示*p的值不允许改变，*p = 100;// error; int b = 20; p = &b; // ok
   int c = 10;
   int * const p = &c; // p存放了一个固定的地址，所以初始化的时候要给他一个初值，表示p的地址不允许改变
   					   // int d = 20; p = &d // error; c = 20; //ok
2. const修饰函数参数
   char* strcpy(char* dst, const char* src); // 防止src在strcpy函数内部被改变

3. const修饰函数返回值
   const int get(); // 防止get() 函数返回值被改变
4. const修饰函数
   int get() const; // 只可以用于类成员函数, 表示get()函数仅可访问类成员变量, 但是不可以改变类成员变量; 只能调用const
   成员函数，因为get()函数隐含了一个const this*指针
5. const和#define的区别
   #define是在预处理截断进行替换; const会在编译阶段替换, 会做安全检查, define只是简单地做替换, const会报错, 便于调试


## 比较const和#define

1. const 常量有数据类型, 而宏常量没有数据类型。编译器可以对前者进行类型安全检查。
   而define只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
2. 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。



## new/free和malloc/delete的区别

1. [性质] new是操作符，操作符可以进行重载，malloc是库函数
2. [使用] new使用的时候会自动计算大小，malloc则要指定大小
3. [成功] new成功后返回对象类型的指针，malloc返回void*指针，需要自己做类型转换
4. [失败] new抛出异常，malloc返回会NULL，所以用new之后在判断是否为NULL没什么意义
5. [扩容] new不支持扩容, malloc在使用过程中发现内存不够可以使用realloc来进行扩容

## strcpy

```
char* strcpy(char* dst, const char* src)
{
	assert(dst!=NULL);
	assert(src!=NULL);
	while((*dst++ = *src++)!= '\0');
	return dst;
}
```

## memcpy

```
char* memcpy(char* dst, const char* src, size_t n)
{
	assert((dst!=NULL) && (src!=NULL));
	while((*dst++ = *src++) != '\0' && --n);
}
```

## strcmp

```
int MyStrcmp(const char* str1, const char* str2)
{
	assert((dst!=NULL) && (src!=NULL));
    while ((*str1++ == *str2++)!='\0' && *str1 && *str2);
    int result = *(--str1) == *(--str2) ? 0 : (*(--str1) > *(--str2) ? 1 : -1);
}
```

## 什么时候要用虚析构函数

1. 虚函数是动态绑定的基础。假如析构函数不是virtual的，就不会发生动态绑定，而是静态绑定，指针的静态类型为基类指针，因此在
   delete时候只会调用基类的析构函数，而不会调用派生类的析构函数。这样，在派生类中申请的资源就不会得到释放，就会造成内存泄漏
2. 由于基类函数是虚函数（派生类相应函数就自动变虚函数，所以派生类同名函数可以不指定为虚函数）


## 对内存的理解

1. 内存管理方式[生存周期]
   静态存储连续性: 函数外定义的变量和使用satic定义的变量, 他们在整个程序运行过程中都存在
   自动存储连续性: 函数内定义的局部变量(包括函数参数), 他们在开始执行所属函数时被创建, 执行完函数后被释放
   线程存储连续性: 用thread_local定义的变量, 其声明周期和所属线程一样
   动态存储连续性: 用new/malloc动态申请的变量, 申请时被创建, 直到用delete/free将其释放

2. 内存分区[如何进行分配存放]
   栈区: 由编译器自动分配释放, 存放函数参数值和局部变量值等
   堆区: 由程序员动态申请释放, 存放用new/malloc等申请的变量
   代码区: 存放二进制代码
   全局区/静态存储区: 这块内存在程序编译的时候就已经分配好了, 存放全局变量和静态变量
   文字常量区: 存放字符串常量, 程序结后由系统释放

3. 内存动态分配
   new和malloc的区别


## 多态实现方式

1. 编译时多态
重载
   同一类中的同名函数是重载, 这些方法的名称相同, 但是参数类型或个数不同, virtual关键字可有可无
   不同类中同名函数可能是覆盖，也可能是隐藏。根据是否有virtual以及函数参数是否相同区分；
隐藏
   指派生类的函数屏蔽了与其同名的基类函数，派生对象都是调用派生类的同名函数。
   1）如果子类的函数与父类同名，但是参数不同，此时不论有无virtual关键字、基类的函数都将被隐藏;
   2）如果子类的函数与父类同名，且参数也相同，但是基类函数没有virtual关键字，此时基类的函数被隐藏
      别和覆盖混淆了,覆盖是必须有virtual关键字

2. 运行时多态
重写(覆盖)
   是指子类重新定义父类虚函数的方法, 以实现不同的功能; 函数体特征相同(函数名、参数类型个数),基类要是虚函数


## 指针

### 数据和指针的区别

1. 修改内容上的差别(比如++运算和字符常量)
2. sizeof的差别

### 引用和指针的区别

1. 引用要在定义的时候就初始化，而且只是个符号，不占用空间
2. 指针可以为空，但是引用不可以为空，而且应用在初始化之后就不许修改了，指针则可以随时改变指向
3. sizeof(引用) = 原变量大小; sizeof（指针）= 4或8字节

### 野指针

1. 产生
   1) 声明指针的时候, 没有初始化为NULL, 这样的话这个指针指向什么地方都是不确定的
   2) 释放动态申请的内存时, 只delete或free了, delete只是表示程序释放
      delete 释放空间，只是做个标志，表示p所在的空间可以被其他进程使用了
      没释放之前，使用权是当前进程的；而且还需把指针p赋为NULL
2. 危害
   1) 指向不可访问地址
   2) 破坏正在使用的地址空间

3. 防范
   定义指针的时候就进行初始化



## 进程

### fork
1. 写时复制(copy-on-write):
   1) fork()进程如果没有调用exec的话, 其代码空间和父进程是一样的
   2) 只有在fork之后exec之前两个进程用的是相同的物理空间（内存区）
      子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说
      两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有
      更改相应段的行为发生时，再为子进程相应的段分配物理空间
   3) 资源的复制只有在写入的时候才进行

### 僵尸进程和孤儿进程

### 守护进程

### 进程间通信



## 线程


### 线程同步

1. mutex、lock_guard、unique_lock

2. condition_variable + unique_lock + notify_once + wait

3. future、promise、async、atomic

### 死锁

1. 产生原因
   陷入互相等待的状态
   A线程锁住了mutex1, 在想用mutex2锁住的变量时尝试锁mutex2, 发现mutex2被锁了, 等待mutex2释放
   B线程锁住了mutex2, 在想用mutex1锁住的变量时尝试锁mutex1, 发现mutex1被锁了, 等待mutex1释放
   原因是A、B线程锁互斥量的顺序不一致, 解锁顺序倒是不影响
2. 解决：
   1) std:lock() 函数模板
      std:lock(mutex1, mutex 2)
      解锁还是要手工unlock()，解锁顺序不影响
      可以一次锁住>=2个互斥量，不存在因锁的顺序问题而导致死锁的存在，会等所有都锁住才继续往下走
      原理:
      如果有一个互斥量没锁成功，则会释放掉已锁成功的互斥量，过段时间再去尝试，直到把所有互斥量都锁住为止
      缺点:
      lock()解决死锁的痛点在于存在忘记unlock的危险，而lock_guard刚好可以自动unlock，可否两者优点都有呢？
   2) lock() 和 lock_guard
      使用lock_guard的adopt_lock参数可以做到，让lock_guard构造的时候不lock, 但是必需在lock_guard之前加锁
      std:lock（mutex1,mutex2)
      lock_guard<mutex>lock_guard(mutex1, adopt_lock)
   3) atomic 原子操作
      类模板atomic声明的对象确保了该操作是原子性的, 不需要加锁
      std::atomic<int> g_atomic_counter(0); // atomic是一个类模板
      g_atomic_counter++;


# 数据结构与算法




# 计算机网络和网络安全


## TCP/UDP的区别

1. 用户数据包协议
   UDP是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。
2. 传输控制协议
   TCP是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流
   把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块

3. TCP通过确认机制，丢包可以重发，保证数据的正确性;
   UDP不保证正确性，只是单纯的负责发送数据包；

4. UDP是面向报文的。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付给 IP 层
   既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小；

5. UDP的头部，只有 8 个字节，相对于TCP头部的 20 个字节信息包的额外开销很小。

## 三次握手

## 长连接、短链接

## HTTP的GET/POST的区别

1. GET：当客户端要从服务端读取数据时用GET，使用GET方法时，请求参数和对应的值 附加在URL后面
   利用问号?代表URL的结尾和请求参数的开始，传递参数长度受限制，例：/index.jsp?id=100&op=bind

2. POST:是向服务器提交数据，POST方法请求参数封装在HTTP请求数据中，可以传输大量数据，可用来传送文件。

3. Get和Post请求的区别：
   Get是向服务器索取数据的一种请求，而Post是向服务器提交数据的一种请求
   [参数传递方式]Get请求的参数会跟在url后进行传递,它对传输的数据有[大小限制] POST请求的数据会放置在请求头内提交
   [安全性]Post比Get安全

## 浏览器输入地址后发生了什么

1. DNS服务把url转ip
2. 进行三次握手, 建立TCP/IP链接
3. 浏览器发起HTTP的post请求
4. 请求由应用层不断包装进入到数据链路层, 然后经过路由转发(拆解到网络层), 最终经过防火墙\NAT到达目的主机
5. 服务器处理该HTTP请求, 返回HTML文件
6. 浏览器解析HTML文件, 展示

## 常用端口


## time_wait状态


## 滑动窗口机制

1. 由发送方和接收方在三次握手阶段，互相将自己的最大可接收的数据量告诉对方, 也就是自己的数据接收缓冲池的大小;
   这样对方可以根据已发送的数据量来计算是否可以接着发送。
2. 在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知

## 拥塞避免机制

1. 拥塞
   对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，网络的吞吐量随之负荷的增大而下降。
2. 拥塞控制
   防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。
3. 拥塞控制方法
   慢启动 + 拥塞避免;
   快重传 + 快恢复。